
		final Item item_1 = new Item("letto", "Un letto nel quale dormono i pazienti.", null);
		bed.setHandler(new CommandHandler() {

			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(bed.getDescription());
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final Weapon item_2 = new Weapon("cacciavite", "Un cacciavite che potrebbe tornare utile.", null, 10, 5, 15);
		screwdriver.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(screwdriver.getDescription());
						}
					};
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							if(t.getCurrentEnemy()!=null && t.getCurrentRoom().hasLight()) {
								if(screwdriver.getShots() != 0) {
									t.getCurrentEnemy().setHealth(t.getCurrentEnemy().getHealth()-screwdriver.getDamage());
									screwdriver.setShots(screwdriver.getShots() - 1);
									switch(screwdriver.getShots()) {
									case 0:
										System.out.println("E'andato, ormai e'inutilizzabile");
										break;
									case 1:
										System.out.println("Il cacciavite e' quasi totalmente distrutto");
										break;
									case 4:
										System.out.println("Ti rimangono un altro paio di colpi prima che si rompa");
										break;
									case 7:
										System.out.println("Il cacciavite si sta iniziando a dannegiare");
										break;
									}
								} else System.out.println("Il cacciavite e'ormai distrutto, non farebbe nessun danno");
							} else System.out.println("Non sembra esserci nessuno da colpire!");
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(screwdriver, t);
							System.out.println("Hai lasciato il cacciavite!");
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(screwdriver, t);
								System.out.println("Hai preso il cacciavite!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final Item item_3 = new Item("maschera-gas", "Una maschera per proteggerti dai gas tossici.", null);
		gasmask.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				switch(t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(gasmask.getDescription());
						}
					};
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println("Stai indossando correttamente la maschera!");
							((Asylum) t).gasVuln = false;
							bathroom.setDescription("Non appena entri nella stanza, i gas tossici iniziano a circolare nell'aria, ma la maschera ti protegge. Sei nel bagno.");
					     	surgery.setDescription("Non appena entri nella stanza, i gas tossici iniziano a circolare nell'aria, ma la maschera ti protegge. Sei nella stanza dove i pazienti sono sottoposti alle operazioni. Chissa' a questo punto di che operazioni si tratta...");
					     	if(!compassUsed) {
					     		bathroom.setLook("Potresti sfruttare il gabinetto  per...no, meglio evitare. Puoi solo tornare indietro nel corridoio 3.");
							 	surgery.setLook("Puoi solo tornare indietro nel corridoio 4.");

					     	}
					     	else {
					     		bathroom.setLook("Potresti sfruttare il gabinetto per...no, meglio evitare. Puoi solo tornare indietro a sud nel corridoio 3.");
							 	surgery.setLook("Puoi solo tornare indietro nel corridoio 4 a ovest.");
						}
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(gasmask, t);
								System.out.println("Hai preso la maschera!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(gasmask, t);
							((Asylum) t).gasVuln = true;
							System.out.println("Hai lasciato la maschera!");
							bathroom.setDescription("");
					        surgery.setDescription("");
							if(compassUsed) {
								bathroom.setLook("L'effetto del gas ti stordisce e non ti permette di vedere nulla. Puoi solo tornare indietro a sud nel corridoio 3.");
						        surgery.setLook("L'effetto del gas ti stordisce e non ti permette di vedere nulla. Puoi solo tornare indietro nel corridoio 4 a ovest.");
						        }
							else {
								bathroom.setLook("L'effetto del gas ti stordisce e non ti permette di vedere nulla. Puoi solo tornare indietro nel corridoio 3.");
						        surgery.setLook("L'effetto del gas ti stordisce e non ti permette di vedere nulla. Puoi solo tornare indietro nel corridoio 4.");
						}
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final Item item_4 = new Item("torcia", "Una torcia utile per illuminare gli spazi bui.", null);
		torch.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case USE:
				case TURN_ON:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println("Hai acceso la torcia!");
							t.getCurrentRoom().setLight(true);
							if (t.getCurrentRoom().equals(paddedCell) && t.getCurrentRoom().getTrap()!= null) {
								t.getCurrentRoom().getTrap().accept(t);
							}
						}
					};
				case TURN_OFF:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							t.getCurrentRoom().setVisible(t.getCurrentRoom().hasLight());
							System.out.println("Hai spento la torcia!");
						}
					};
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(torch.getDescription());
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(torch, t);
							System.out.println("Hai lasciato la torcia!");
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(torch, t);
								System.out.println("Hai preso la torcia!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final Item item_5 = new Item("pillole", "Delle pillole che ti rendono immune temporaneamente ai gas tossici.", null);
		pills.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							if(t.getInventory().getList().contains(pills)) {
								System.out.println("L'effetto delle pillole ti rende temporaneamente immune ai gas tossici!");
								((Asylum) t).breathedGas = false;
								t.getInventory().remove(pills);
							} else System.out.println("L'oggetto non e'presente nell'inventario!");
						}
					};
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(pills.getDescription());
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(pills, t);
							System.out.println("Hai lasciato le pillole!");
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(pills, t);
								System.out.println("Hai preso le pillole!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final Item item_6 = new Item("adrenalina", "Delle siringhe di adrenalina che ti incrementano la salute.", null);
		adrenaline.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							if(t.getInventory().getList().contains(adrenaline)) {
								System.out.println("L'effetto dell'adrenalina incrementa la tua salute:");
								((Asylum) t).health += 20;
								System.out.println("+20 salute");
								t.getInventory().remove(adrenaline);
							} else System.out.println("L'oggetto non e'presente nell'inventario!");
						}
					};
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(adrenaline.getDescription());
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(adrenaline, t);
							System.out.println("Hai lasciato l'adrenalina!");
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(adrenaline, t);
								System.out.println("Hai preso l'adrenalina!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final Item item_7 = new Item("specchio", "Uno specchio in cui viene riflessa la tua immagine. Mmm, non sei poi cosi' male.", null);
		mirrorBathroom.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(mirrorBathroom.getDescription());
						}
					};
				case BREAK:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							if(!mirrorBathroom.isPushed()) {
								t.getCurrentRoom().getObjects().add(pills);
								mirrorBathroom.setPushed(true);
								System.out.println("Hai rotto lo specchio!");
							}
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final Item item_8 = new Item("bussola", "Una bussola utile per un miglior orientamento nella mappa.", null);
		compass.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(compass.getDescription());
						}
					};
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							System.out.println("Grazie all'utilizzo della bussola ora sai in che direzione sono le porte e ti e' possibile spostarti utilizzando i punti cardinali come comandi!");
							room1.setLook("Vedi una porta a sud che conduce nel corridoio 1.");
							room2.setLook("Puoi solo tornare indietro nel corridoio 1 a sud.");
							room3.setLook("Non vedi altre porte. Puoi solo tornare nel corridoio 2 a sud.");
							room4.setLook("Puoi solo tornare indietro nel corridoio 2 a sud.");
							room5.setLook("Puoi solo tornare indietro nel corridoio 1 a nord.");
							room6.setLook("Qualche paziente sperava forse che bastasse fare qualche buco per crearsi una via di fuga...Puoi solo tornare indietro nel corridoio 1 a nord.");
							room7.setLook("Puoi solo tornare indietro nel corridoio 2 a nord.");
							room8.setLook("Non vedi altre porte, puoi solo tornare indietro nel corridoio 2 a nord.");
							hallway.setLook("Puoi proseguire a est per il corridoio 2 o entrare nel dormitorio 1 a nord-ovest, 2 a nord-est, 5 a sud-ovest, o 6 a sud-est.");
							hallway2.setLook("Il sangue e' dappertutto. Puoi tornare indietro ad ovest nel corridoio 1, proseguire ad est per il corridoio 3, entrare nella lavanderia a nord-ovest o entrare nel dormitorio 4 a nord-est, 7 a sud-ovest, 8 a sud-est.");
							hallway3.setLook("Vedi scheletri ovunque. Puoi tornare indietro ad ovest nel corridoio 2, entrare nel bagno a nord, o prendere le scale per scendere al piano inferiore");
							if (((Asylum) t).gasVuln == true) {
								bathroom.setLook("L'effetto del gas ti stordisce e non ti permette di vedere nulla. Puoi solo tornare indietro a sud nel corridoio 3.");
									}
							else {
								bathroom.setLook("Potresti sfruttare il gabinetto per...no, meglio evitare. Puoi solo tornare indietro a sud nel corridoio 3.");
									}
							hallway4.setLook("Puoi tornare a nord verso il piano superiore o accedere all'infermeria a nord-est, alla sala operatoria a sud-est e alla sorveglianza ad ovest.");
							infirmary.setLook("Puoi solo tornare indietro nel corridoio 4 ad ovest.");
							surgery.setLook("Puoi solo tornare indietro nel corridoio 4 ad ovest.");
							surveillance.setLook("Puoi tornare nel corridoio 4 ad est o proseguire a sud verso la cella imbottita.");
							paddedCell.setLook("Apparentemente, puoi solo tornare indietro nella sorveglianza a nord.");
							office.setLook("Vedi delle scale a sud che conducono all'esterno della struttura, ma il passaggio e' bloccato dal direttore. Puoi tornare indietro a nord nella cella imbottita.");
							((Asylum) t).compassUsed = true;

						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(compass, t);
							System.out.println("Hai lasciato la bussola!");
							((Asylum) t).compassUsed = false;
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(compass, t);
								System.out.println("Hai preso la bussola!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final ItemContainer item_9 = new ItemContainer("cassa", "Una cassa che potrebbe contenere qualcosa al suo interno.", null);
		chest.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							if(!chest.isOpened()) {
								System.out.println(chest.getDescription());
							}else {
								System.out.println("Questa cassa contiene: ");
								for(Item i: chest.getContent()) {
									System.out.println(i.getName());
								}
								for(Item i: chest.getContent()) {
									if(!t.getCurrentRoom().getObjects().contains(i)) t.getCurrentRoom().getObjects().add(i);
								}
							}
						}
					};
				case OPEN:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							if(chest.isOpened()) {
								System.out.println("Cassa gia' aperta");
							}else if(!chest.isOpened() && !chest.isLocked()) {
									System.out.println("Hai aperto la cassa!");
									chest.setOpened(true);
								  }else if(chest.isLocked()) {
									System.out.println("E' bloccata! Probabilmente hai bisogno di una chiave...");
								  }
						}
					};
				case CLOSE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
								if (!chest.isOpened()) {
									System.out.println("La cassa e' gia' chiusa!");}
									else {
										System.out.println("Hai chiuso la cassa!");
										for(Item i: chest.getContent()) t.getCurrentRoom().getObjects().remove(i);
										chest.setOpened(false);
									}
								}

					};
				default:
					return invalidCommand;
				}
			}
		});

		final Item item_10 = new Item("pc", "Un computer utilizzato per interagire con i sistemi di sicurezza.", null);
		pc.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println("Accendi il PC: vengono mostrati i video degli esperimenti sui pazienti. Ora ricordi: stavi indagando sulla scomparsa di un paziente all'interno del manicomio quando qualcuno ti ha colpito alla testa! Dai video emerge che questi esperimenti causano delle mutazioni nei pazienti!");						}
					};
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(pc.getDescription());
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final Weapon item_11 = new Weapon("bisturi", "Un bisturi utilizzato negli esperimenti.", null, 5, 10, 30);
		scalpel.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(scalpel.getDescription());
						}
					};
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							if(t.getCurrentEnemy()!=null && t.getCurrentRoom().hasLight()) {
								if(scalpel.getShots() != 0) {
									t.getCurrentEnemy().setHealth(t.getCurrentEnemy().getHealth()-scalpel.getDamage());
									scalpel.setShots(scalpel.getShots() - 1);
									switch(scalpel.getShots()) {
									case 0:
										System.out.println("Noo! la lama del bisturi si e' rotta");
										break;
									case 1:
										System.out.println("La lama se ne sta venendo");
										break;
									case 4:
										System.out.println("Il bisturi e' molto fragile si danneggia molto facilmente");
										break;
									}
								} else System.out.println("Questo bisturi ha perso la lama, non ti potra' piu' essere d'aiuto");
							}else System.out.println("Non sembra esserci nessuno da colpire!");
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(scalpel, t);
							System.out.println("Hai lasciato il bisturi!");
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(scalpel, t);
								System.out.println("Hai preso il bisturi!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				default:
					return invalidCommand;
				}
			}
		});


		final Weapon item_12 = new Weapon("pistola", "Una pistola probabilmente utilizzata contro i pazienti piu' inquieti e difficili da controllare.", null, 7, 30, 70);
		gun.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(gun.getDescription());
						}
					};
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							if(t.getCurrentEnemy()!=null && t.getCurrentRoom().hasLight()) {
								if(gun.getShots() != 0) {
									t.getCurrentEnemy().setHealth(t.getCurrentEnemy().getHealth()-gun.getDamage());
									gun.setShots(gun.getShots() - 1);
									switch(gun.getShots()) {
									case 0:
										System.out.println("Il caricatore e' finito, munizioni esaurite");
										break;
									case 1:
										System.out.println("Ultimo colpo usalo bene");
										break;
									case 5:
										System.out.println("Hai solo un caricatore ti restano quindi 5 colpi");
										break;
									}
								} else System.out.println("Ops... hai finito le munizioni");
							}else System.out.println("Non sembra esserci nessuno da colpire!");
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(gun, t);
							System.out.println("Hai lasciato la pistola!");
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(gun, t);
								System.out.println("Hai preso la pistola!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final Item item_13 = new Item("specchio", "Uno specchio in cui viene riflessa la tua immagine. Mmm, non sei poi cosi' male.", null);
		mirrorCell.setHandler(new CommandHandler() {
			@Override
			public EventHandler apply(CommandType t) {
				// TODO Auto-generated method stub
				switch (t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(mirrorCell.getDescription());
						}
					};
				case BREAK:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							WeightedHashedGraph<Room, Gateway> m = t.getMap();
							if(!mirrorCell.isPushed()) {
								//inserire l'arco
								m.insArc(paddedCell, office, new Gateway(Direction.SOUTH));
								mirrorCell.setPushed(true);
								System.out.println("La rottura dello specchio ti rivela un passaggio segreto a sud nell'ufficio del direttore!");
							}
						}
					};
				default:
					return invalidCommand;
				}
			}
		});

		final Item item_14 = new Item("foglio", "Il codice e' 5030", null);
		codePaper.setHandler(new CommandHandler() {

			@Override
			public EventHandler apply(CommandType t) {
				switch(t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(codePaper.getDescription());
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(codePaper, t);
								System.out.println("Hai preso il foglio!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(codePaper, t);
							System.out.println("Hai lasciato il foglio!");
						}
					};
				default:
					return invalidCommand;
				}};
		});

		final Item item_15 = new Item("blocco-note", "Un quaderno di appunti che a giudicare dalla grafia sembra proprio essere il tuo. A quanto pare stavi raccogliendo dati su questa struttura e indizi per la risoluzione di un caso, ma non riesci a ricordare bene. Avevi sottolineato piu' volte \"DEVO ROMPERE LO SPECCHIO PER PROSEGUIRE\"...", null);
		blockNotes.setHandler(new CommandHandler() {

			@Override
			public EventHandler apply(CommandType t) {
				switch(t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(blockNotes.getDescription());
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(blockNotes, t);
								System.out.println("Hai preso il blocco-note!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(blockNotes, t);
							System.out.println("Hai lasciato il blocco-note!");
						}
					};
				default:
					return invalidCommand;
				}};
		});

		final Item item_16 = new Item("tastierino", "Un tastierino numerico in cui inserire un codice situato accanto alla porta per il corridoio 3.", null);
		keypad.setHandler(new CommandHandler() {

			@Override
			public EventHandler apply(CommandType t) {
				switch(t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(keypad.getDescription());
						}
					};
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							if (hallway3.getTrap()!=null){
								if(!keypad.isPushed()) {
									Scanner scan = new Scanner(System.in);
									System.out.println(":");
									String codEntered = scan.nextLine();
									String[] tokens = codePaper.getDescription().split("\\s+");
									if(codEntered.equals(tokens[3])) {
										hallway3.setTrap(null);
										System.out.println("Codice esatto! La trappola e' stata disattivata!");
										keypad.setPushed(true);
									} else System.out.println("Codice errato!");
								} else System.out.println("Trappola gia' disattivata");
							}else System.out.println("Trappola gia' disattivata!");

						}
					};
				default:
					return invalidCommand;
				}};
		});





		final Item item_17 = new Item("chiave", "Una chiave che potrebbe tornare utile per aprire qualcosa.", null);
		key.setHandler(new CommandHandler() {

			@Override
			public EventHandler apply(CommandType t) {
				switch(t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(key.getDescription());
						}
					};
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							WeightedHashedGraph<Room, Gateway> m = t.getMap();
							if(t.getInventory().getList().contains(key)) {
								if(t.getCurrentRoom().equals(room1)) {
									try {
										for(Room a : m.getAdjacents(t.getCurrentRoom())) {
											if(m.readArc(t.getCurrentRoom(), a).getLockedBy()==key.getId()) {
												if (!m.readArc(t.getCurrentRoom(), a).isLocked()) System.out.println("La porta e' gia' aperta!");
												else {
													m.readArc(t.getCurrentRoom(), a).setLocked(false);
													System.out.println("La chiave sembra entrare perfettamente nella serratura della porta che conduce nel corridoio 1!");												EventHandler.drop(key, t);
													break;
												}
											}
										}
									} catch (Exception e) {
										System.out.println(e.getMessage());
									}
								}else System.out.println("Non c'e' niente da aprire con questa chiave nella stanza!");
							} else System.out.println("Prendi la chiave per usarla");
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(key, t);
								corpse.setDescription("Un corpo esanime dall'odore stomacevole. Deve essere li' da tanto tempo.");
								System.out.println("Hai preso la chiave!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}

						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(key, t);
							System.out.println("Hai lasciato la chiave!");
						}
					};
				default:
					return invalidCommand;
				}};
		});



		Item item_18= new Item("chiave-assistente", "Sembra la chiave di una porta...", null);
		key_1.setHandler(new CommandHandler() {

			@Override
			public EventHandler apply(CommandType t) {
				switch(t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(key_1.getDescription());
						}
					};
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							WeightedHashedGraph<Room, Gateway> m = t.getMap();
							if(t.getInventory().getList().contains(key_1)) {
								if(t.getCurrentRoom().equals(paddedCell)) {
									try {
										for(Room a : m.getAdjacents(t.getCurrentRoom())) {
											if(m.readArc(t.getCurrentRoom(), a).getLockedBy()==key_1.getId()) {
												if (!m.readArc(t.getCurrentRoom(), a).isLocked()) System.out.println("La porta e' gia' aperta!");
												else {
													m.readArc(t.getCurrentRoom(), a).setLocked(false);
													System.out.println("La chiave sembra entrare perfettamente nella serratura della porta che conduce alla sorveglianza");
													EventHandler.drop(key_1, t);
													break;
												}
											}
										}
									} catch (Exception e) {
										System.out.println(e.getMessage());
									}
								}else System.out.println("Non c'e' niente da aprire con questa chiave nella stanza!");
							} else System.out.println("Prendi la chiave per usarla");
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(key_1, t);
								System.out.println("Hai preso la chiave!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(key_1, t);
							System.out.println("Hai lasciato la chiave!");
						}
					};
				default:
					return invalidCommand;
				}};
		});

		Item item_19= new Item("chiave-direttore", "Sembra la chiave di una porta...", null);
		key_2.setHandler(new CommandHandler() {

			@Override
			public EventHandler apply(CommandType t) {
				switch(t) {
				case LOOK_AT:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							System.out.println(key_2.getDescription());
						}
					};
				case USE:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							WeightedHashedGraph<Room, Gateway> m = t.getMap();
							if(t.getInventory().getList().contains(key_2)) {
								if(t.getCurrentRoom().equals(office)) {
									try {
										for(Room a : m.getAdjacents(t.getCurrentRoom())) {
											if(m.readArc(t.getCurrentRoom(), a).getLockedBy()==key_2.getId()) {
												if (!m.readArc(t.getCurrentRoom(), a).isLocked()) System.out.println("La porta e' gia' aperta!");
												else {
													m.readArc(t.getCurrentRoom(), a).setLocked(false);
													System.out.println("La chiave sembra entrare perfettamente nella serratura della porta che conduce all'uscita!");
													EventHandler.drop(key_2, t);
													break;
												}
											}
										}
									} catch (Exception e) {
										System.out.println(e.getMessage());
									}
								}else System.out.println("Non c'e' niente da aprire con questa chiave nella stanza!");
							} else System.out.println("Prendi la chiave per usarla");
						}
					};
				case PICK_UP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							try {
								EventHandler.pickUp(key_2, t);
								System.out.println("Hai preso la chiave!");
							} catch (InvalidCommandException e) {
								// TODO Auto-generated catch block
								System.out.println("Oggetto non presente nella stanza");
							}
						}
					};
				case DROP:
					return new EventHandler() {
						@Override
						public void accept(GameDescription t) {
							// TODO Auto-generated method stub
							EventHandler.drop(key_2, t);
							System.out.println("Hai lasciato la chiave!");
						}
					};
				default:
					return invalidCommand;
				}};
		});
